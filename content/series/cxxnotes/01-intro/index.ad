---
title: "第 01 讲：快速入门"
summary: "串讲 C++ 中的基本概念，让读者快速入门"
draft: true
---

== 基本元素

=== 基础类型

NOTE: “基础类型”对应于英文 primitive type，很多资料将其翻译成“基本类型”，不过我们后面会发现，所有的 $$C++$$ 程序都是在这些类型的基础上实现的，因此我个人更倾向于译为“基础类型”。

如果说程序设计语言中最基础的概念是什么，我想应该就是类型，类型规定了其成员和可以对成员进行的操作，没有这一点，其他内容都无从谈起。

我们与计算机进行交互是为了处理数据，最常见的数据就是数值，而数值又有自然数和小数之分。$$C++$$ 也提供了两类对应的类型：__整型__ 和__浮点型__，它们统称为“算术类型”。其中，整型包含 `int`，浮点型包含 `float` 和 `double`，分别表示单精度浮点数和双精度浮点数，二者的区别我们稍候讨论。

在如今典型的 64 位机器上 `int` 的宽度是 32-bit，能够表示十亿这个量级的数值，然而这有一些明显的局限：

* 如果我们只想存储很小的数值，而且不想浪费空间，该怎么办？
* 我们知道，当今的机器都是字节寻址的，如果我们想访问 `int` 中的一个字节，该怎么做？
* 如果我们想要表示更大的值，该怎么办？
* 如果能够确保数据是大于 0 的，如何充分利用 32 个比特的空间？

为了应对这些问题，$$C++$$ 提供了宽度修饰符：

* ``short``，在典型的 64 位机器上，``short int`` 是 16-bit 的
* ``long``，在典型的 64 位机器上，``long int`` 是 64-bit 的
* ``signed``，用于表示有符号数
* ``unsigned``，用于表示无符号数

例如，``unsigned long int`` 表示 64-bit 的无符号数，最大值为 2^64^ - 1.

|===
|              | char              | short int           | int                 | long int

| **signed**   | [-2^7^, 2^7^ - 1] | [-2^15^, 2^15^ - 1] | [-2^31^, 2^31^ - 1] | [-2^63^, 2^63^ - 1]
| **unsigned** | [0, 2^8^ - 1]     |[0, 2^16^ - 1]       | [0, 2^32^ - 1]      | [0, 2^64^ - 1]
|===

如果只能够顺序地进行计算，那我们很难构造出有用的程序，毕竟我们的日常生活中也会面临诸多的决策。$$C++$$ 为此提供了__逻辑类型__ `bool`，这个类型只有两个值 `true` 和 `false`，分别表示逻辑真和逻辑假。

算术类型和逻辑类型加上我们后面会讨论的运算符和控制流结构，已经是图灵完备的了。但是，我们还需要一个与计算机进行交互的界面。对人类来说，最自然的界面当然就是文字（在计算机发展的早期，这个界面是一组灯泡亮或不亮，或是打孔卡，想想每次都搞得跟情报站工作人员一样会有多痛苦）。$$C++$$ 提供了__字符类型__ `char`，用以表示 <<bib:ascii,ASCII>> 字符集中的文字。

NOTE: 现代 $$C++$$ 提供了处理其他编码规范（例如，UTF-8）的字符类型，这一点我们会专门讲解。

注意到前文介绍的数值类型并不能表示最基本的寻址单元——字节，由于 ASCII 字符编码是 1 个字节，因此在 $$C++$$ 中，我们用 ``signed char`` 和 ``unsigned char`` 表示 8-bit 的整数，
$$C++17$$ 引入了 `std::byte` 类型，可以用来表示一个无符号 8-bit 整数。

NOTE: `char` 是 `unsigned` 还是 `signed` 是 implementation-defined 的行为，如果要表示 8-bit 整数，尽量指明 `signed` 或 `unsigned`

我们前面对于各个类型宽度的介绍都加了限定词“在典型的 64 位平台上”，这是因为 $$C++$$ 标准并没有精确的规定宽度，而是用了相对的方式：

* `char` 的宽度是 8 个比特
* `short` 宽度不小于 `char`
* `int` 宽度不小于 `short`
* `long` 宽度至少是 32，且不小于 `int`

例如，某些平台上 `long int` 的宽度是 32 位。

如果需要精确地控制宽度，可以使用 `cstdint` 中定义的 ``(u)int8_t``、``(u)int16_t``、``(u)int32_t`` 和 ``(u)int64_t``.

此外 $$C++$$ 还为指针提供了 ``uintptr_t`` 类型。

// .Undefined、Implementation Defined 和 Unspecified
// ****
// xuz
// ****

//=== 类型修饰符

//const / volatile

== 组合

=== 组合数据

[source,c++]
----
struct Pair {
  int first;
  int second;
};
----

==== 运算符

==== 控制流


=== 组合类型

==== 数组

==== 指针和引用

== 抽象


[bibliography]
== 参考

* [[[bib:ascii,1]]]
